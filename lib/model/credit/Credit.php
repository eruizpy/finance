<?php


/**
 * Skeleton subclass for representing a row from the 'credit' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.2 on:
 *
 * Sun Feb 20 16:26:33 2011
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model.credit
 */
class Credit extends BaseCredit 
{
  /**
   * status attribute = approved
   */
  const STATUS_APPROVED = 'approved';
  
  /**
   * status attribute = annulled
   */
  const STATUS_ANNULLED = 'annulled';
  
  /**
   * status attribute = in_request
   */
  const STATUS_IN_REQUEST = 'in_request';
  
  /**
   * status attribute = current
   */
  const STATUS_CURRENT = 'current';
  
  /**
   * status attribute = paid
   */
  const STATUS_PAID = 'paid';

  /**
   * Post insert 
   * 
   * @param PropelPDO $con 
   */
  public function postInsert(PropelPDO $con = null) 
  {
    $this->setAmortizationType($this->getProduct()->getAmortizationType());
    $this->save();
    parent::postInsert($con);
  }

  /**
   * Get isInRequest
   * 
   * @return boolean 
   */
  public function isInRequest()
  {
    return $this->CompareStatus(self::STATUS_IN_REQUEST);
  }

  /**
   * Get isApproved
   * 
   * @return boolean 
   */
  public function isApproved()
  {
    return $this->CompareStatus(self::STATUS_APPROVED);
  }

  /**
   * Get isAnnulled
   * 
   * @return boolean 
   */
  public function isAnnulled()
  {
    return $this->CompareStatus(self::STATUS_ANNULLED);
  }

  /**
   * Get isPaid
   * 
   * @return boolean 
   */
  public function isPaid()
  {
    return $this->CompareStatus(self::STATUS_PAID);
  }

  /**
   * Get isCurrent
   * 
   * @return boolean 
   */
  public function isCurrent()
  {
    return $this->CompareStatus(self::STATUS_CURRENT);
  }
  
  /**
   * Compare status credit
   * 
   * @param string $status credit status
   * @return boolean 
   */
  private function CompareStatus($status)
  {
    $b = false;
    if($this->getStatus() == $status){
      $b = true;
    }

    return $b;
  }
  
  /**
   * Get status text
   * 
   * @return string 
   */
  public function getStatusText()
  {
    $statusText = ucfirst(str_replace('_', ' ', $this->getStatus()));
    
    return $statusText;
  }

  /**
   * Count payments effected
     * 
   * @return int 
   */
  public function CountPaymentsEffected()
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::STATUS, Payment::STATUS_PAID);
    
    return $this->countPayments($criteria);
  }
  
  /**
   * Get payments effected
   * 
   * @return amortizatios  
   */
  public function gePaymentsEffected()
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::STATUS, Payment::STATUS_PAID, Criteria::EQUAL);
    
    return $this->getPayments($criteria);
  }
  
  /**
   * Count payments pending
   * 
   * @return int
   */
  public function CountPaymentsPending()
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::STATUS, Payment::STATUS_UNPAID, Criteria::EQUAL);
    
    return $this->countPayments($criteria);
  }
  
  /**
   * Get payments pending
   * 
   * @param int $limit Limit
   * @return  array amortizations 
   */
  public function getPaymentsPending($limit = null)
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::STATUS, Payment::STATUS_UNPAID, Criteria::EQUAL);
    $criteria->addAscendingOrderByColumn(PaymentPeer::NUMBER);
    
    if($limit){
      $criteria->setLimit($limit);
    }
    
    return $this->getPayments($criteria);
  }
  
  /**
   * Get expired payments
   * 
   * @param int $limit
   * @return array 
   */
  public function getExpiredPayments($limit = null)
  {
    $now = mktime(0, 0, 0, date("m")  , date("d"), date("Y"));
    
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::STATUS, Payment::STATUS_UNPAID, Criteria::EQUAL);
    $criteria->add(PaymentPeer::DATE, $now, Criteria::LESS_EQUAL);
    $criteria->addAscendingOrderByColumn(PaymentPeer::NUMBER);
    
    if($limit){
      $criteria->setLimit($limit);
    }
    
    return $this->getPayments($criteria);
  }

  /**
   * Get nex payment
   * 
   * @return Payment 
   */
  public function getNextPayment()
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::CREDIT_ID, $this->getId(), Criteria::EQUAL);
    $criteria->add(PaymentPeer::STATUS, Payment::STATUS_UNPAID, Criteria::EQUAL);
    $criteria->addAscendingOrderByColumn(PaymentPeer::ID);
    
    return PaymentPeer::doSelectOne($criteria);
  }
   
  /**
   * Get interest total
   * 
   * @return decimal 
   */
  public function getInterestTotal()
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::CREDIT_ID, $this->getId(), Criteria::EQUAL);

    $sum = PaymentPeer::sum(PaymentPeer::INTEREST, $criteria);
    
    return $sum;
  }
  
  /**
   * Get payment total
   * 
   * @return decimal 
   */
  public function getPaymentTotal()
  {
    $sum = $this->getCapitalTotal() + $this->getInterestTotal();
    
    return $sum;
  }
  
  /**
   * Get capital total
   * 
   * @return decimal 
   */ 
  public function getCapitalTotal()
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::CREDIT_ID, $this->getId(), Criteria::EQUAL);

    $sum = PaymentPeer::sum(PaymentPeer::CAPITAL, $criteria);
    
    return $sum;
  }
  
  /**
   * Get payment pending
   * 
   * @return decimal 
   */
  public function getPaymentPending()
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::CREDIT_ID, $this->getId());
    $criteria->add(PaymentPeer::STATUS, Payment::STATUS_UNPAID);
    $criteria->addAscendingOrderByColumn(PaymentPeer::ID);
 
    $sum = PaymentPeer::sum(PaymentPeer::TOTAL, $criteria);
    
    return $sum;
  }

  /**
   * Get arrear pending
   * 
   * @return decimal
   */
  public function getArrearPending()
  {
    $payments = $this->getPaymentsPending();
    
    $arrear = 0.00;
    
    $arrear = PaymentPeer::sumArrear($payments);
    
    return $arrear;
  }
  
  /**
   * Get amount pending
   * 
   * @return decimal
   */
  public function getAmountPending()
  {
    $amount = $this->getArrearPending() + $this->getPaymentPending();
    
    return $amount;
  }
  
  /**
   * Transfer to account
   * 
   * @param Cash $connection
   * @param sfGuardUser $user
   * @param TransactionType $cdtTransactionType
   * @param TransactionType $actTransactionType 
   */
  public function disbursement(sfGuardUser $user, TransactionType $cdtTransactionType, TransactionType $actTransactionType)
  {
    $credit = $this;
    
    $account = $this->getAccount();
    
    $amount = $this->getAmount();
    
    $con = Propel::getConnection(CreditPeer::DATABASE_NAME, Propel::CONNECTION_WRITE);

    $con->beginTransaction();
    try{
        //build transaction credit
        $transaction = new Transaction($user, $cdtTransactionType, $amount);
        $transaction->save($con);
        
        $creditTransaction = new CreditTransaction($transaction, $credit);
        $creditTransaction->save($con);

        //update credit status
        $credit->setStatus(Credit::STATUS_CURRENT);
        $credit->save($con);
        
        //build transacction account
        $transaction = new Transaction($user, $actTransactionType, $amount); 
        $transaction->save($con);
        
        $accountTransaction = new AccountTransaction($transaction, $account);
        $accountTransaction->save($con);

        $con->commit();

    }catch (Exception $e){
      $con->rollBack();
      throw $e;
    }
  }
  
  /**
   * Pay the payments
   * 
   * @param sfGuardUser $user
   * @param Cash $connection
   * @param TransactionType $actTransactionType
   * @param TransactionType $cdtTransactionType
   * @param int $number number of payments 
   */
  public function pay(sfGuardUser $user, TransactionType $actTransactionType, TransactionType $cdtTransactionType, $number)
  {
    $payments = $this->getPaymentsPending($number);
    
    $con = Propel::getConnection(PaymentPeer::DATABASE_NAME, Propel::CONNECTION_WRITE);

    $con->beginTransaction();
    
    try {
      
      foreach ($payments as $payment){
        $payment->pay($user, $actTransactionType, $cdtTransactionType);
      }
      
      $con->commit();
      
    } catch (Exception $e) {
      
      $con->rollBack();
      throw $e;
    }
    
  }

  /**
   * Method toString
   * 
   * @return string getExpiredPayments
   */
  public function  __toString()
  {
    return $this->getId().' / '.$this->getAssociate()->getName();
  }
}
